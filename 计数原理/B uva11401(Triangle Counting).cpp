#include<stdio.h>  
long long f[1000005], x;
//设最大边长为x的三角形有c（x）个，另外两边长分别为y，z，则可得x-y<z<x；固定x枚举y，计算个数0+1+2+...+(x-2)=(x-1)(x-2)/2。上面的解包含了y=z的情况，而且其他情况算了两遍。而y=z的情况时y从x/2+1枚举到x-1为止有（x-1）/2个解，所以c（x）=((x-1)*(x-2)/2-(x-1)/2)/2。
//由以上分析可得，最大边长不超过n的三角形数目为f（n） = c（1） + c（2） + ... + c（n）。
int main()
{
    int n;
    f[3] = 0;
    for (x = 4; x <= 1000000; x++)//离线+递推计算  
        f[x] = f[x - 1] + ((x - 1)*(x - 2) / 2 - (x - 1) / 2) / 2;
    while (scanf("%d", &n) == 1)
    {
        if (n<3) break;
        printf("%lld\n", f[n]);
    }
    return 0;
}